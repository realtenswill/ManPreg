<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake — ManPheng Industries</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --green: #A0C878;
      --green-dark: #a0c878;
      --blue: #6DA8FF;
      --bg: #2f6c81;
      --panel: #a0c878;
      --text: #143d64;
      --grid: #487e90;
      --accent: #4fd1c5;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: linear-gradient(180deg, #2f6c81, #2f6c81 40%, #2f6c81);
      color: var(--text);
      font-family: "Roboto", sans-serif;
      display: flex;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
      padding: 1.25rem;
    }

    .wrap {
      width: 100%;
      max-width: 900px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .title {
      display: flex;
      align-items: baseline;
      gap: 0.75rem;
    }
    .title h1 {
      margin: 0;
      font-weight: 700;
      font-size: 1.75rem;
      color: var(--green);
      letter-spacing: 0.5px;
    }
    .title .beta {
      font-weight: 500;
      color: var(--blue);
      font-size: 0.95rem;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .btn {
      background: var(--panel);
      border: 1px solid var(--green-dark);
      color: var(--text);
      padding: 0.5rem 0.9rem;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.06s ease, box-shadow 0.12s ease;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn.primary {
      background: linear-gradient(180deg, var(--green), var(--green-dark));
      color: #143d64;
      font-weight: 700;
      border: none;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--green-dark);
      border-radius: 14px;
      padding: 1rem;
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .stats {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
      font-weight: 500;
    }

    .canvas-wrap {
      position: relative;
      background:
        linear-gradient(0deg, transparent 24px, var(--grid) 24px, var(--grid) 26px, transparent 26px),
        linear-gradient(90deg, transparent 24px, var(--grid) 24px, var(--grid) 26px, transparent 26px);
      background-size: 26px 26px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--green-dark);
    }

    canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      aspect-ratio: 1 / 1; /* keep square on responsive screens */
      background: #a0c878;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #487e90;
      backdrop-filter: blur(2px);
      text-align: center;
      padding: 1rem;
    }
    .overlay.visible { display: flex; }
    .overlay .box {
      background: #a0c878;
      border: 1px solid var(--green-dark);
      border-radius: 12px;
      padding: 1rem 1.25rem;
      max-width: 420px;
    }
    .overlay h2 {
      margin: 0 0 0.5rem 0;
      color: var(--green);
    }
    .overlay p { margin: 0.5rem 0; }
    .kbd {
      display: inline-block;
      background: #487e90;
      border: 1px solid #487e90;
      border-radius: 6px;
      padding: 0.1rem 0.35rem;
      font-size: 0.85rem;
      color: #cfe8c5;
    }

    .footer-note {
      text-align: right;
      opacity: 0.8;
      font-size: 0.9rem;
    }

    @media (max-width: 40rem) {
      .header { flex-direction: column; align-items: flex-start; }
      .footer-note { text-align: left; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">
        <h1>Snake — Play locally</h1>
        <span class="beta"></span>
      </div>
      <div class="controls">
        <button class="btn primary" id="play">Play</button>
        <button class="btn" id="pause">Pause</button>
        <button class="btn" id="reset">Reset</button>
        <button class="btn" id="speed">Speed: Normal</button>
      </div>
    </div>

    <div class="panel">
      <div class="stats">
        <div><strong>Score:</strong> <span id="score">0</span></div>
        <div><strong>High score:</strong> <span id="high">0</span></div>
        <div><strong>Current turn:</strong> <span id="turn">→</span></div>
      </div>

      <div class="canvas-wrap">
        <canvas id="board" width="416" height="416" aria-label="Snake game board"></canvas>

        <div class="overlay" id="overlay">
          <div class="box">
            <h2>Game over</h2>
            <p>Your score: <strong id="finalScore">0</strong></p>
            <p>Press <span class="kbd">Enter</span> or click <span class="kbd">Play</span> to restart.</p>
          </div>
        </div>
      </div>

      <div class="footer-note">
        Use arrow keys or WASD. Avoid the walls and yourself. Eat food to grow.
      </div>
    </div>
  </div>

  <script>
    // Theme
    const COLORS = {
      bg: "#487e90",
      snake: "#A0C878",
      snakeHead: "#6FA85B",
      food: "#6DA8FF",
      grid: "#2f6c81",
      wall: "#a0c878",
      text: "#143d60",
    };

    // Board setup
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const CELL = 16; // px per cell (416 / 16 = 26 cells)
    const COLS = Math.floor(canvas.width / CELL);
    const ROWS = Math.floor(canvas.height / CELL);

    // UI
    const scoreEl = document.getElementById("score");
    const highEl = document.getElementById("high");
    const turnEl = document.getElementById("turn");
    const overlay = document.getElementById("overlay");
    const finalScoreEl = document.getElementById("finalScore");
    const playBtn = document.getElementById("play");
    const pauseBtn = document.getElementById("pause");
    const resetBtn = document.getElementById("reset");
    const speedBtn = document.getElementById("speed");

    // Game state
    let snake, dir, nextDir, food, score, high, running, tickMs;

    function init() {
      snake = [
        { x: 8, y: 13 },
        { x: 7, y: 13 },
        { x: 6, y: 13 },
      ];
      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
      score = 0;
      running = false;
      tickMs = 120;
      food = spawnFood();
      scoreEl.textContent = score;
      turnEl.textContent = "→";
      overlay.classList.remove("visible");
      draw();
    }

    function spawnFood() {
      while (true) {
        const x = Math.floor(Math.random() * COLS);
        const y = Math.floor(Math.random() * ROWS);
        if (!snake.some(s => s.x === x && s.y === y)) return { x, y };
      }
    }

    function setHigh() {
      const stored = localStorage.getItem("snakeHigh") || "0";
      high = Math.max(parseInt(stored, 10), score);
      localStorage.setItem("snakeHigh", String(high));
      highEl.textContent = high;
    }

    function start() {
      if (running) return;
      running = true;
      loop();
    }

    function pause() { running = false; }

    function loop() {
      if (!running) return;
      step();
      draw();
      setTimeout(loop, tickMs);
    }

    function step() {
      dir = nextDir;
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // Collision: walls
      if (head.x < 0 || head.y < 0 || head.x >= COLS || head.y >= ROWS) {
        gameOver();
        return;
      }
      // Collision: self
      if (snake.some(s => s.x === head.x && s.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      // Eat food
      if (head.x === food.x && head.y === food.y) {
        score += 1;
        scoreEl.textContent = score;
        food = spawnFood();
        if (score % 5 === 0) tickMs = Math.max(70, tickMs - 5); // gradual speed-up
      } else {
        snake.pop();
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 1;
      for (let i = 1; i < COLS; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL, 0);
        ctx.lineTo(i * CELL, canvas.height);
        ctx.stroke();
      }
      for (let j = 1; j < ROWS; j++) {
        ctx.beginPath();
        ctx.moveTo(0, j * CELL);
        ctx.lineTo(canvas.width, j * CELL);
        ctx.stroke();
      }

      // Food
      drawCell(food.x, food.y, COLORS.food);

      // Snake
      snake.forEach((seg, i) => {
        drawCell(seg.x, seg.y, i === 0 ? COLORS.snakeHead : COLORS.snake);
      });
    }

    function drawCell(x, y, color) {
      const pad = 1;
      ctx.fillStyle = color;
      ctx.fillRect(x * CELL + pad, y * CELL + pad, CELL - pad * 2, CELL - pad * 2);
    }

    function gameOver() {
      running = false;
      finalScoreEl.textContent = score;
      setHigh();
      overlay.classList.add("visible");
    }

    function setDir(nx, ny, glyph) {
      // prevent reverse into self
      if (nx === -dir.x && ny === -dir.y) return;
      nextDir = { x: nx, y: ny };
      turnEl.textContent = glyph;
    }

    // Keyboard controls
    window.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowUp": case "w": case "W": setDir(0, -1, "↑"); break;
        case "ArrowDown": case "s": case "S": setDir(0, 1, "↓"); break;
        case "ArrowLeft": case "a": case "A": setDir(-1, 0, "←"); break;
        case "ArrowRight": case "d": case "D": setDir(1, 0, "→"); break;
        case "Enter": start(); break;
        case " ": pause(); break;
      }
    });

    // Buttons
    playBtn.addEventListener("click", () => start());
    pauseBtn.addEventListener("click", () => pause());
    resetBtn.addEventListener("click", () => init());
    speedBtn.addEventListener("click", () => {
      const speeds = [
        { label: "Chill", ms: 160 },
        { label: "Normal", ms: 120 },
        { label: "Snappy", ms: 90 },
        { label: "Turbo", ms: 70 },
      ];
      const current = speeds.findIndex(s => s.ms === tickMs);
      const next = (current + 1) % speeds.length;
      tickMs = speeds[next].ms;
      speedBtn.textContent = `Speed: ${speeds[next].label}`;
    });

    // Touch controls (simple swipe)
    let touchStart = null;
    canvas.addEventListener("touchstart", (e) => {
      const t = e.touches[0];
      touchStart = { x: t.clientX, y: t.clientY };
    });
    canvas.addEventListener("touchend", (e) => {
      if (!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 20) setDir(1, 0, "→"); else if (dx < -20) setDir(-1, 0, "←");
      } else {
        if (dy > 20) setDir(0, 1, "↓"); else if (dy < -20) setDir(0, -1, "↑");
      }
      touchStart = null;
    });

    // Boot
    init();
    setHigh();
  </script>
</body>
</html>